// Code generated by goa v3.1.2, DO NOT EDIT.
//
// notes HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/fieldkit/cloud/server/api/design

package client

import (
	"bytes"
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strconv"

	notes "github.com/fieldkit/cloud/server/api/gen/notes"
	notesviews "github.com/fieldkit/cloud/server/api/gen/notes/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildUpdateRequest instantiates a HTTP request object with method and path
// set to call the "notes" service "update" endpoint
func (c *Client) BuildUpdateRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		stationID int32
	)
	{
		p, ok := v.(*notes.UpdatePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("notes", "update", "*notes.UpdatePayload", v)
		}
		stationID = p.StationID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateNotesPath(stationID)}
	req, err := http.NewRequest("PATCH", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("notes", "update", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateRequest returns an encoder for requests sent to the notes update
// server.
func EncodeUpdateRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*notes.UpdatePayload)
		if !ok {
			return goahttp.ErrInvalidType("notes", "update", "*notes.UpdatePayload", v)
		}
		{
			head := p.Auth
			req.Header.Set("Authorization", head)
		}
		body := NewUpdateRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("notes", "update", err)
		}
		return nil
	}
}

// DecodeUpdateResponse returns a decoder for responses returned by the notes
// update endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeUpdateResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeUpdateResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "update", err)
			}
			p := NewUpdateFieldNotesOK(&body)
			view := "default"
			vres := &notesviews.FieldNotes{Projected: p, View: view}
			if err = notesviews.ValidateFieldNotes(vres); err != nil {
				return nil, goahttp.ErrValidationError("notes", "update", err)
			}
			res := notes.NewFieldNotes(vres)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body UpdateUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "update", err)
			}
			err = ValidateUpdateUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "update", err)
			}
			return nil, NewUpdateUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body UpdateForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "update", err)
			}
			err = ValidateUpdateForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "update", err)
			}
			return nil, NewUpdateForbidden(&body)
		case http.StatusNotFound:
			var (
				body UpdateNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "update", err)
			}
			err = ValidateUpdateNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "update", err)
			}
			return nil, NewUpdateNotFound(&body)
		case http.StatusBadRequest:
			var (
				body UpdateBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "update", err)
			}
			err = ValidateUpdateBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "update", err)
			}
			return nil, NewUpdateBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("notes", "update", resp.StatusCode, string(body))
		}
	}
}

// BuildGetRequest instantiates a HTTP request object with method and path set
// to call the "notes" service "get" endpoint
func (c *Client) BuildGetRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		stationID int32
	)
	{
		p, ok := v.(*notes.GetPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("notes", "get", "*notes.GetPayload", v)
		}
		stationID = p.StationID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetNotesPath(stationID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("notes", "get", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetRequest returns an encoder for requests sent to the notes get
// server.
func EncodeGetRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*notes.GetPayload)
		if !ok {
			return goahttp.ErrInvalidType("notes", "get", "*notes.GetPayload", v)
		}
		{
			head := p.Auth
			req.Header.Set("Authorization", head)
		}
		return nil
	}
}

// DecodeGetResponse returns a decoder for responses returned by the notes get
// endpoint. restoreBody controls whether the response body should be restored
// after having been read.
// DecodeGetResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeGetResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "get", err)
			}
			p := NewGetFieldNotesOK(&body)
			view := "default"
			vres := &notesviews.FieldNotes{Projected: p, View: view}
			if err = notesviews.ValidateFieldNotes(vres); err != nil {
				return nil, goahttp.ErrValidationError("notes", "get", err)
			}
			res := notes.NewFieldNotes(vres)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body GetUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "get", err)
			}
			err = ValidateGetUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "get", err)
			}
			return nil, NewGetUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body GetForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "get", err)
			}
			err = ValidateGetForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "get", err)
			}
			return nil, NewGetForbidden(&body)
		case http.StatusNotFound:
			var (
				body GetNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "get", err)
			}
			err = ValidateGetNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "get", err)
			}
			return nil, NewGetNotFound(&body)
		case http.StatusBadRequest:
			var (
				body GetBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "get", err)
			}
			err = ValidateGetBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "get", err)
			}
			return nil, NewGetBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("notes", "get", resp.StatusCode, string(body))
		}
	}
}

// BuildDownloadMediaRequest instantiates a HTTP request object with method and
// path set to call the "notes" service "download media" endpoint
func (c *Client) BuildDownloadMediaRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		mediaID int32
	)
	{
		p, ok := v.(*notes.DownloadMediaPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("notes", "download media", "*notes.DownloadMediaPayload", v)
		}
		mediaID = p.MediaID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DownloadMediaNotesPath(mediaID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("notes", "download media", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDownloadMediaRequest returns an encoder for requests sent to the notes
// download media server.
func EncodeDownloadMediaRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*notes.DownloadMediaPayload)
		if !ok {
			return goahttp.ErrInvalidType("notes", "download media", "*notes.DownloadMediaPayload", v)
		}
		{
			head := p.Auth
			req.Header.Set("Authorization", head)
		}
		return nil
	}
}

// DecodeDownloadMediaResponse returns a decoder for responses returned by the
// notes download media endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeDownloadMediaResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeDownloadMediaResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				length      int64
				contentType string
				err         error
			)
			{
				lengthRaw := resp.Header.Get("Content-Length")
				if lengthRaw == "" {
					return nil, goahttp.ErrValidationError("notes", "download media", goa.MissingFieldError("Content-Length", "header"))
				}
				v, err2 := strconv.ParseInt(lengthRaw, 10, 64)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("length", lengthRaw, "integer"))
				}
				length = v
			}
			contentTypeRaw := resp.Header.Get("Content-Type")
			if contentTypeRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("Content-Type", "header"))
			}
			contentType = contentTypeRaw
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "download media", err)
			}
			res := NewDownloadMediaResultOK(length, contentType)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body DownloadMediaUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "download media", err)
			}
			err = ValidateDownloadMediaUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "download media", err)
			}
			return nil, NewDownloadMediaUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body DownloadMediaForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "download media", err)
			}
			err = ValidateDownloadMediaForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "download media", err)
			}
			return nil, NewDownloadMediaForbidden(&body)
		case http.StatusNotFound:
			var (
				body DownloadMediaNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "download media", err)
			}
			err = ValidateDownloadMediaNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "download media", err)
			}
			return nil, NewDownloadMediaNotFound(&body)
		case http.StatusBadRequest:
			var (
				body DownloadMediaBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "download media", err)
			}
			err = ValidateDownloadMediaBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "download media", err)
			}
			return nil, NewDownloadMediaBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("notes", "download media", resp.StatusCode, string(body))
		}
	}
}

// BuildUploadMediaRequest instantiates a HTTP request object with method and
// path set to call the "notes" service "upload media" endpoint
func (c *Client) BuildUploadMediaRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		stationID int32
		body      io.Reader
	)
	{
		rd, ok := v.(*notes.UploadMediaRequestData)
		if !ok {
			return nil, goahttp.ErrInvalidType("notes", "upload media", "notes.UploadMediaRequestData", v)
		}
		p := rd.Payload
		body = rd.Body
		stationID = p.StationID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UploadMediaNotesPath(stationID)}
	req, err := http.NewRequest("POST", u.String(), body)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("notes", "upload media", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUploadMediaRequest returns an encoder for requests sent to the notes
// upload media server.
func EncodeUploadMediaRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		data, ok := v.(*notes.UploadMediaRequestData)
		if !ok {
			return goahttp.ErrInvalidType("notes", "upload media", "*notes.UploadMediaRequestData", v)
		}
		p := data.Payload
		{
			head := p.ContentType
			req.Header.Set("Content-Type", head)
		}
		{
			head := p.ContentLength
			headStr := strconv.FormatInt(head, 10)
			req.Header.Set("Content-Length", headStr)
		}
		{
			head := p.Auth
			req.Header.Set("Authorization", head)
		}
		values := req.URL.Query()
		values.Add("key", p.Key)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeUploadMediaResponse returns a decoder for responses returned by the
// notes upload media endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeUploadMediaResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeUploadMediaResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UploadMediaResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "upload media", err)
			}
			p := NewUploadMediaNoteMediaOK(&body)
			view := "default"
			vres := &notesviews.NoteMedia{Projected: p, View: view}
			if err = notesviews.ValidateNoteMedia(vres); err != nil {
				return nil, goahttp.ErrValidationError("notes", "upload media", err)
			}
			res := notes.NewNoteMedia(vres)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body UploadMediaUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "upload media", err)
			}
			err = ValidateUploadMediaUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "upload media", err)
			}
			return nil, NewUploadMediaUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body UploadMediaForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "upload media", err)
			}
			err = ValidateUploadMediaForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "upload media", err)
			}
			return nil, NewUploadMediaForbidden(&body)
		case http.StatusNotFound:
			var (
				body UploadMediaNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "upload media", err)
			}
			err = ValidateUploadMediaNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "upload media", err)
			}
			return nil, NewUploadMediaNotFound(&body)
		case http.StatusBadRequest:
			var (
				body UploadMediaBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("notes", "upload media", err)
			}
			err = ValidateUploadMediaBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("notes", "upload media", err)
			}
			return nil, NewUploadMediaBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("notes", "upload media", resp.StatusCode, string(body))
		}
	}
}

// // BuildUploadMediaStreamPayload creates a streaming endpoint request payload
// from the method payload and the path to the file to be streamed
func BuildUploadMediaStreamPayload(payload interface{}, fpath string) (*notes.UploadMediaRequestData, error) {
	f, err := os.Open(fpath)
	if err != nil {
		return nil, err
	}
	return &notes.UploadMediaRequestData{
		Payload: payload.(*notes.UploadMediaPayload),
		Body:    f,
	}, nil
}

// marshalNotesFieldNoteUpdateToFieldNoteUpdateRequestBody builds a value of
// type *FieldNoteUpdateRequestBody from a value of type *notes.FieldNoteUpdate.
func marshalNotesFieldNoteUpdateToFieldNoteUpdateRequestBody(v *notes.FieldNoteUpdate) *FieldNoteUpdateRequestBody {
	res := &FieldNoteUpdateRequestBody{}
	if v.Notes != nil {
		res.Notes = make([]*ExistingFieldNoteRequestBody, len(v.Notes))
		for i, val := range v.Notes {
			res.Notes[i] = marshalNotesExistingFieldNoteToExistingFieldNoteRequestBody(val)
		}
	}
	if v.Creating != nil {
		res.Creating = make([]*NewFieldNoteRequestBody, len(v.Creating))
		for i, val := range v.Creating {
			res.Creating[i] = marshalNotesNewFieldNoteToNewFieldNoteRequestBody(val)
		}
	}

	return res
}

// marshalNotesExistingFieldNoteToExistingFieldNoteRequestBody builds a value
// of type *ExistingFieldNoteRequestBody from a value of type
// *notes.ExistingFieldNote.
func marshalNotesExistingFieldNoteToExistingFieldNoteRequestBody(v *notes.ExistingFieldNote) *ExistingFieldNoteRequestBody {
	res := &ExistingFieldNoteRequestBody{
		ID:   v.ID,
		Key:  v.Key,
		Body: v.Body,
	}
	if v.MediaIds != nil {
		res.MediaIds = make([]int64, len(v.MediaIds))
		for i, val := range v.MediaIds {
			res.MediaIds[i] = val
		}
	}

	return res
}

// marshalNotesNewFieldNoteToNewFieldNoteRequestBody builds a value of type
// *NewFieldNoteRequestBody from a value of type *notes.NewFieldNote.
func marshalNotesNewFieldNoteToNewFieldNoteRequestBody(v *notes.NewFieldNote) *NewFieldNoteRequestBody {
	res := &NewFieldNoteRequestBody{
		Key:  v.Key,
		Body: v.Body,
	}
	if v.MediaIds != nil {
		res.MediaIds = make([]int64, len(v.MediaIds))
		for i, val := range v.MediaIds {
			res.MediaIds[i] = val
		}
	}

	return res
}

// marshalFieldNoteUpdateRequestBodyToNotesFieldNoteUpdate builds a value of
// type *notes.FieldNoteUpdate from a value of type *FieldNoteUpdateRequestBody.
func marshalFieldNoteUpdateRequestBodyToNotesFieldNoteUpdate(v *FieldNoteUpdateRequestBody) *notes.FieldNoteUpdate {
	res := &notes.FieldNoteUpdate{}
	if v.Notes != nil {
		res.Notes = make([]*notes.ExistingFieldNote, len(v.Notes))
		for i, val := range v.Notes {
			res.Notes[i] = marshalExistingFieldNoteRequestBodyToNotesExistingFieldNote(val)
		}
	}
	if v.Creating != nil {
		res.Creating = make([]*notes.NewFieldNote, len(v.Creating))
		for i, val := range v.Creating {
			res.Creating[i] = marshalNewFieldNoteRequestBodyToNotesNewFieldNote(val)
		}
	}

	return res
}

// marshalExistingFieldNoteRequestBodyToNotesExistingFieldNote builds a value
// of type *notes.ExistingFieldNote from a value of type
// *ExistingFieldNoteRequestBody.
func marshalExistingFieldNoteRequestBodyToNotesExistingFieldNote(v *ExistingFieldNoteRequestBody) *notes.ExistingFieldNote {
	res := &notes.ExistingFieldNote{
		ID:   v.ID,
		Key:  v.Key,
		Body: v.Body,
	}
	if v.MediaIds != nil {
		res.MediaIds = make([]int64, len(v.MediaIds))
		for i, val := range v.MediaIds {
			res.MediaIds[i] = val
		}
	}

	return res
}

// marshalNewFieldNoteRequestBodyToNotesNewFieldNote builds a value of type
// *notes.NewFieldNote from a value of type *NewFieldNoteRequestBody.
func marshalNewFieldNoteRequestBodyToNotesNewFieldNote(v *NewFieldNoteRequestBody) *notes.NewFieldNote {
	res := &notes.NewFieldNote{
		Key:  v.Key,
		Body: v.Body,
	}
	if v.MediaIds != nil {
		res.MediaIds = make([]int64, len(v.MediaIds))
		for i, val := range v.MediaIds {
			res.MediaIds[i] = val
		}
	}

	return res
}

// unmarshalFieldNoteResponseBodyToNotesviewsFieldNoteView builds a value of
// type *notesviews.FieldNoteView from a value of type *FieldNoteResponseBody.
func unmarshalFieldNoteResponseBodyToNotesviewsFieldNoteView(v *FieldNoteResponseBody) *notesviews.FieldNoteView {
	res := &notesviews.FieldNoteView{
		ID:        v.ID,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
		Key:       v.Key,
		Body:      v.Body,
		Version:   v.Version,
	}
	res.Author = unmarshalFieldNoteAuthorResponseBodyToNotesviewsFieldNoteAuthorView(v.Author)
	res.Media = make([]*notesviews.NoteMediaView, len(v.Media))
	for i, val := range v.Media {
		res.Media[i] = unmarshalNoteMediaResponseBodyToNotesviewsNoteMediaView(val)
	}

	return res
}

// unmarshalFieldNoteAuthorResponseBodyToNotesviewsFieldNoteAuthorView builds a
// value of type *notesviews.FieldNoteAuthorView from a value of type
// *FieldNoteAuthorResponseBody.
func unmarshalFieldNoteAuthorResponseBodyToNotesviewsFieldNoteAuthorView(v *FieldNoteAuthorResponseBody) *notesviews.FieldNoteAuthorView {
	res := &notesviews.FieldNoteAuthorView{
		ID:       v.ID,
		Name:     v.Name,
		MediaURL: v.MediaURL,
	}

	return res
}

// unmarshalNoteMediaResponseBodyToNotesviewsNoteMediaView builds a value of
// type *notesviews.NoteMediaView from a value of type *NoteMediaResponseBody.
func unmarshalNoteMediaResponseBodyToNotesviewsNoteMediaView(v *NoteMediaResponseBody) *notesviews.NoteMediaView {
	res := &notesviews.NoteMediaView{
		ID:          v.ID,
		URL:         v.URL,
		Key:         v.Key,
		ContentType: v.ContentType,
	}

	return res
}

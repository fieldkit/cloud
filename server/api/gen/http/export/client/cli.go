// Code generated by goa v3.1.2, DO NOT EDIT.
//
// export HTTP client CLI support package
//
// Command:
// $ goa gen github.com/fieldkit/cloud/server/api/design

package client

import (
	"fmt"
	"strconv"

	export "github.com/fieldkit/cloud/server/api/gen/export"
)

// BuildListMinePayload builds the payload for the export list mine endpoint
// from CLI flags.
func BuildListMinePayload(exportListMineAuth string) (*export.ListMinePayload, error) {
	var auth string
	{
		auth = exportListMineAuth
	}
	v := &export.ListMinePayload{}
	v.Auth = auth

	return v, nil
}

// BuildStatusPayload builds the payload for the export status endpoint from
// CLI flags.
func BuildStatusPayload(exportStatusID string, exportStatusAuth string) (*export.StatusPayload, error) {
	var id string
	{
		id = exportStatusID
	}
	var auth string
	{
		auth = exportStatusAuth
	}
	v := &export.StatusPayload{}
	v.ID = id
	v.Auth = auth

	return v, nil
}

// BuildDownloadPayload builds the payload for the export download endpoint
// from CLI flags.
func BuildDownloadPayload(exportDownloadID string, exportDownloadAuth string) (*export.DownloadPayload, error) {
	var id string
	{
		id = exportDownloadID
	}
	var auth string
	{
		auth = exportDownloadAuth
	}
	v := &export.DownloadPayload{}
	v.ID = id
	v.Auth = auth

	return v, nil
}

// BuildCsvPayload builds the payload for the export csv endpoint from CLI
// flags.
func BuildCsvPayload(exportCsvStart string, exportCsvEnd string, exportCsvStations string, exportCsvSensors string, exportCsvResolution string, exportCsvAggregate string, exportCsvComplete string, exportCsvTail string, exportCsvAuth string) (*export.CsvPayload, error) {
	var err error
	var start *int64
	{
		if exportCsvStart != "" {
			val, err := strconv.ParseInt(exportCsvStart, 10, 64)
			start = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for start, must be INT64")
			}
		}
	}
	var end *int64
	{
		if exportCsvEnd != "" {
			val, err := strconv.ParseInt(exportCsvEnd, 10, 64)
			end = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for end, must be INT64")
			}
		}
	}
	var stations *string
	{
		if exportCsvStations != "" {
			stations = &exportCsvStations
		}
	}
	var sensors *string
	{
		if exportCsvSensors != "" {
			sensors = &exportCsvSensors
		}
	}
	var resolution *int32
	{
		if exportCsvResolution != "" {
			var v int64
			v, err = strconv.ParseInt(exportCsvResolution, 10, 32)
			val := int32(v)
			resolution = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for resolution, must be INT32")
			}
		}
	}
	var aggregate *string
	{
		if exportCsvAggregate != "" {
			aggregate = &exportCsvAggregate
		}
	}
	var complete *bool
	{
		if exportCsvComplete != "" {
			var val bool
			val, err = strconv.ParseBool(exportCsvComplete)
			complete = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for complete, must be BOOL")
			}
		}
	}
	var tail *int32
	{
		if exportCsvTail != "" {
			var v int64
			v, err = strconv.ParseInt(exportCsvTail, 10, 32)
			val := int32(v)
			tail = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for tail, must be INT32")
			}
		}
	}
	var auth string
	{
		auth = exportCsvAuth
	}
	v := &export.CsvPayload{}
	v.Start = start
	v.End = end
	v.Stations = stations
	v.Sensors = sensors
	v.Resolution = resolution
	v.Aggregate = aggregate
	v.Complete = complete
	v.Tail = tail
	v.Auth = auth

	return v, nil
}

// BuildJSONLinesPayload builds the payload for the export json lines endpoint
// from CLI flags.
func BuildJSONLinesPayload(exportJSONLinesStart string, exportJSONLinesEnd string, exportJSONLinesStations string, exportJSONLinesSensors string, exportJSONLinesResolution string, exportJSONLinesAggregate string, exportJSONLinesComplete string, exportJSONLinesTail string, exportJSONLinesAuth string) (*export.JSONLinesPayload, error) {
	var err error
	var start *int64
	{
		if exportJSONLinesStart != "" {
			val, err := strconv.ParseInt(exportJSONLinesStart, 10, 64)
			start = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for start, must be INT64")
			}
		}
	}
	var end *int64
	{
		if exportJSONLinesEnd != "" {
			val, err := strconv.ParseInt(exportJSONLinesEnd, 10, 64)
			end = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for end, must be INT64")
			}
		}
	}
	var stations *string
	{
		if exportJSONLinesStations != "" {
			stations = &exportJSONLinesStations
		}
	}
	var sensors *string
	{
		if exportJSONLinesSensors != "" {
			sensors = &exportJSONLinesSensors
		}
	}
	var resolution *int32
	{
		if exportJSONLinesResolution != "" {
			var v int64
			v, err = strconv.ParseInt(exportJSONLinesResolution, 10, 32)
			val := int32(v)
			resolution = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for resolution, must be INT32")
			}
		}
	}
	var aggregate *string
	{
		if exportJSONLinesAggregate != "" {
			aggregate = &exportJSONLinesAggregate
		}
	}
	var complete *bool
	{
		if exportJSONLinesComplete != "" {
			var val bool
			val, err = strconv.ParseBool(exportJSONLinesComplete)
			complete = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for complete, must be BOOL")
			}
		}
	}
	var tail *int32
	{
		if exportJSONLinesTail != "" {
			var v int64
			v, err = strconv.ParseInt(exportJSONLinesTail, 10, 32)
			val := int32(v)
			tail = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for tail, must be INT32")
			}
		}
	}
	var auth string
	{
		auth = exportJSONLinesAuth
	}
	v := &export.JSONLinesPayload{}
	v.Start = start
	v.End = end
	v.Stations = stations
	v.Sensors = sensors
	v.Resolution = resolution
	v.Aggregate = aggregate
	v.Complete = complete
	v.Tail = tail
	v.Auth = auth

	return v, nil
}

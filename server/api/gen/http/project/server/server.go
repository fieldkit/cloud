// Code generated by goa v3.2.4, DO NOT EDIT.
//
// project HTTP server
//
// Command:
// $ goa gen github.com/fieldkit/cloud/server/api/design

package server

import (
	"context"
	"net/http"
	"regexp"

	project "github.com/fieldkit/cloud/server/api/gen/project"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
	"goa.design/plugins/v3/cors"
)

// Server lists the project service endpoint HTTP handlers.
type Server struct {
	Mounts              []*MountPoint
	AddUpdate           http.Handler
	DeleteUpdate        http.Handler
	ModifyUpdate        http.Handler
	Invites             http.Handler
	LookupInvite        http.Handler
	AcceptProjectInvite http.Handler
	RejectProjectInvite http.Handler
	AcceptInvite        http.Handler
	RejectInvite        http.Handler
	Add                 http.Handler
	Update              http.Handler
	Get                 http.Handler
	ListCommunity       http.Handler
	ListMine            http.Handler
	Invite              http.Handler
	RemoveUser          http.Handler
	AddStation          http.Handler
	RemoveStation       http.Handler
	Delete              http.Handler
	UploadPhoto         http.Handler
	DownloadPhoto       http.Handler
	CORS                http.Handler
}

// ErrorNamer is an interface implemented by generated error structs that
// exposes the name of the error as defined in the design.
type ErrorNamer interface {
	ErrorName() string
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the project service endpoints using
// the provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *project.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) *Server {
	return &Server{
		Mounts: []*MountPoint{
			{"AddUpdate", "POST", "/projects/{projectId}/updates"},
			{"DeleteUpdate", "DELETE", "/projects/{projectId}/updates/{updateId}"},
			{"ModifyUpdate", "POST", "/projects/{projectId}/updates/{updateId}"},
			{"Invites", "GET", "/projects/invites/pending"},
			{"LookupInvite", "GET", "/projects/invites/{token}"},
			{"AcceptProjectInvite", "POST", "/projects/{projectId}/invites/accept"},
			{"RejectProjectInvite", "POST", "/projects/{projectId}/invites/reject"},
			{"AcceptInvite", "POST", "/projects/invites/{id}/accept"},
			{"RejectInvite", "POST", "/projects/invites/{id}/reject"},
			{"Add", "POST", "/projects"},
			{"Update", "PATCH", "/projects/{projectId}"},
			{"Get", "GET", "/projects/{projectId}"},
			{"ListCommunity", "GET", "/projects"},
			{"ListMine", "GET", "/user/projects"},
			{"Invite", "POST", "/projects/{projectId}/invite"},
			{"RemoveUser", "DELETE", "/projects/{projectId}/members"},
			{"AddStation", "POST", "/projects/{projectId}/stations/{stationId}"},
			{"RemoveStation", "DELETE", "/projects/{projectId}/stations/{stationId}"},
			{"Delete", "DELETE", "/projects/{projectId}"},
			{"UploadPhoto", "POST", "/projects/{projectId}/media"},
			{"DownloadPhoto", "GET", "/projects/{projectId}/media"},
			{"CORS", "OPTIONS", "/projects/{projectId}/updates"},
			{"CORS", "OPTIONS", "/projects/{projectId}/updates/{updateId}"},
			{"CORS", "OPTIONS", "/projects/invites/pending"},
			{"CORS", "OPTIONS", "/projects/invites/{token}"},
			{"CORS", "OPTIONS", "/projects/{projectId}/invites/accept"},
			{"CORS", "OPTIONS", "/projects/{projectId}/invites/reject"},
			{"CORS", "OPTIONS", "/projects/invites/{id}/accept"},
			{"CORS", "OPTIONS", "/projects/invites/{id}/reject"},
			{"CORS", "OPTIONS", "/projects"},
			{"CORS", "OPTIONS", "/projects/{projectId}"},
			{"CORS", "OPTIONS", "/user/projects"},
			{"CORS", "OPTIONS", "/projects/{projectId}/invite"},
			{"CORS", "OPTIONS", "/projects/{projectId}/members"},
			{"CORS", "OPTIONS", "/projects/{projectId}/stations/{stationId}"},
			{"CORS", "OPTIONS", "/projects/{projectId}/media"},
		},
		AddUpdate:           NewAddUpdateHandler(e.AddUpdate, mux, decoder, encoder, errhandler, formatter),
		DeleteUpdate:        NewDeleteUpdateHandler(e.DeleteUpdate, mux, decoder, encoder, errhandler, formatter),
		ModifyUpdate:        NewModifyUpdateHandler(e.ModifyUpdate, mux, decoder, encoder, errhandler, formatter),
		Invites:             NewInvitesHandler(e.Invites, mux, decoder, encoder, errhandler, formatter),
		LookupInvite:        NewLookupInviteHandler(e.LookupInvite, mux, decoder, encoder, errhandler, formatter),
		AcceptProjectInvite: NewAcceptProjectInviteHandler(e.AcceptProjectInvite, mux, decoder, encoder, errhandler, formatter),
		RejectProjectInvite: NewRejectProjectInviteHandler(e.RejectProjectInvite, mux, decoder, encoder, errhandler, formatter),
		AcceptInvite:        NewAcceptInviteHandler(e.AcceptInvite, mux, decoder, encoder, errhandler, formatter),
		RejectInvite:        NewRejectInviteHandler(e.RejectInvite, mux, decoder, encoder, errhandler, formatter),
		Add:                 NewAddHandler(e.Add, mux, decoder, encoder, errhandler, formatter),
		Update:              NewUpdateHandler(e.Update, mux, decoder, encoder, errhandler, formatter),
		Get:                 NewGetHandler(e.Get, mux, decoder, encoder, errhandler, formatter),
		ListCommunity:       NewListCommunityHandler(e.ListCommunity, mux, decoder, encoder, errhandler, formatter),
		ListMine:            NewListMineHandler(e.ListMine, mux, decoder, encoder, errhandler, formatter),
		Invite:              NewInviteHandler(e.Invite, mux, decoder, encoder, errhandler, formatter),
		RemoveUser:          NewRemoveUserHandler(e.RemoveUser, mux, decoder, encoder, errhandler, formatter),
		AddStation:          NewAddStationHandler(e.AddStation, mux, decoder, encoder, errhandler, formatter),
		RemoveStation:       NewRemoveStationHandler(e.RemoveStation, mux, decoder, encoder, errhandler, formatter),
		Delete:              NewDeleteHandler(e.Delete, mux, decoder, encoder, errhandler, formatter),
		UploadPhoto:         NewUploadPhotoHandler(e.UploadPhoto, mux, decoder, encoder, errhandler, formatter),
		DownloadPhoto:       NewDownloadPhotoHandler(e.DownloadPhoto, mux, decoder, encoder, errhandler, formatter),
		CORS:                NewCORSHandler(),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "project" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.AddUpdate = m(s.AddUpdate)
	s.DeleteUpdate = m(s.DeleteUpdate)
	s.ModifyUpdate = m(s.ModifyUpdate)
	s.Invites = m(s.Invites)
	s.LookupInvite = m(s.LookupInvite)
	s.AcceptProjectInvite = m(s.AcceptProjectInvite)
	s.RejectProjectInvite = m(s.RejectProjectInvite)
	s.AcceptInvite = m(s.AcceptInvite)
	s.RejectInvite = m(s.RejectInvite)
	s.Add = m(s.Add)
	s.Update = m(s.Update)
	s.Get = m(s.Get)
	s.ListCommunity = m(s.ListCommunity)
	s.ListMine = m(s.ListMine)
	s.Invite = m(s.Invite)
	s.RemoveUser = m(s.RemoveUser)
	s.AddStation = m(s.AddStation)
	s.RemoveStation = m(s.RemoveStation)
	s.Delete = m(s.Delete)
	s.UploadPhoto = m(s.UploadPhoto)
	s.DownloadPhoto = m(s.DownloadPhoto)
	s.CORS = m(s.CORS)
}

// Mount configures the mux to serve the project endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountAddUpdateHandler(mux, h.AddUpdate)
	MountDeleteUpdateHandler(mux, h.DeleteUpdate)
	MountModifyUpdateHandler(mux, h.ModifyUpdate)
	MountInvitesHandler(mux, h.Invites)
	MountLookupInviteHandler(mux, h.LookupInvite)
	MountAcceptProjectInviteHandler(mux, h.AcceptProjectInvite)
	MountRejectProjectInviteHandler(mux, h.RejectProjectInvite)
	MountAcceptInviteHandler(mux, h.AcceptInvite)
	MountRejectInviteHandler(mux, h.RejectInvite)
	MountAddHandler(mux, h.Add)
	MountUpdateHandler(mux, h.Update)
	MountGetHandler(mux, h.Get)
	MountListCommunityHandler(mux, h.ListCommunity)
	MountListMineHandler(mux, h.ListMine)
	MountInviteHandler(mux, h.Invite)
	MountRemoveUserHandler(mux, h.RemoveUser)
	MountAddStationHandler(mux, h.AddStation)
	MountRemoveStationHandler(mux, h.RemoveStation)
	MountDeleteHandler(mux, h.Delete)
	MountUploadPhotoHandler(mux, h.UploadPhoto)
	MountDownloadPhotoHandler(mux, h.DownloadPhoto)
	MountCORSHandler(mux, h.CORS)
}

// MountAddUpdateHandler configures the mux to serve the "project" service "add
// update" endpoint.
func MountAddUpdateHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/{projectId}/updates", f)
}

// NewAddUpdateHandler creates a HTTP handler which loads the HTTP request and
// calls the "project" service "add update" endpoint.
func NewAddUpdateHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeAddUpdateRequest(mux, decoder)
		encodeResponse = EncodeAddUpdateResponse(encoder)
		encodeError    = EncodeAddUpdateError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "add update")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteUpdateHandler configures the mux to serve the "project" service
// "delete update" endpoint.
func MountDeleteUpdateHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/projects/{projectId}/updates/{updateId}", f)
}

// NewDeleteUpdateHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "delete update" endpoint.
func NewDeleteUpdateHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteUpdateRequest(mux, decoder)
		encodeResponse = EncodeDeleteUpdateResponse(encoder)
		encodeError    = EncodeDeleteUpdateError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "delete update")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountModifyUpdateHandler configures the mux to serve the "project" service
// "modify update" endpoint.
func MountModifyUpdateHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/{projectId}/updates/{updateId}", f)
}

// NewModifyUpdateHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "modify update" endpoint.
func NewModifyUpdateHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeModifyUpdateRequest(mux, decoder)
		encodeResponse = EncodeModifyUpdateResponse(encoder)
		encodeError    = EncodeModifyUpdateError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "modify update")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountInvitesHandler configures the mux to serve the "project" service
// "invites" endpoint.
func MountInvitesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/projects/invites/pending", f)
}

// NewInvitesHandler creates a HTTP handler which loads the HTTP request and
// calls the "project" service "invites" endpoint.
func NewInvitesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeInvitesRequest(mux, decoder)
		encodeResponse = EncodeInvitesResponse(encoder)
		encodeError    = EncodeInvitesError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "invites")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountLookupInviteHandler configures the mux to serve the "project" service
// "lookup invite" endpoint.
func MountLookupInviteHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/projects/invites/{token}", f)
}

// NewLookupInviteHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "lookup invite" endpoint.
func NewLookupInviteHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeLookupInviteRequest(mux, decoder)
		encodeResponse = EncodeLookupInviteResponse(encoder)
		encodeError    = EncodeLookupInviteError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "lookup invite")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountAcceptProjectInviteHandler configures the mux to serve the "project"
// service "accept project invite" endpoint.
func MountAcceptProjectInviteHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/{projectId}/invites/accept", f)
}

// NewAcceptProjectInviteHandler creates a HTTP handler which loads the HTTP
// request and calls the "project" service "accept project invite" endpoint.
func NewAcceptProjectInviteHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeAcceptProjectInviteRequest(mux, decoder)
		encodeResponse = EncodeAcceptProjectInviteResponse(encoder)
		encodeError    = EncodeAcceptProjectInviteError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "accept project invite")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountRejectProjectInviteHandler configures the mux to serve the "project"
// service "reject project invite" endpoint.
func MountRejectProjectInviteHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/{projectId}/invites/reject", f)
}

// NewRejectProjectInviteHandler creates a HTTP handler which loads the HTTP
// request and calls the "project" service "reject project invite" endpoint.
func NewRejectProjectInviteHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRejectProjectInviteRequest(mux, decoder)
		encodeResponse = EncodeRejectProjectInviteResponse(encoder)
		encodeError    = EncodeRejectProjectInviteError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "reject project invite")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountAcceptInviteHandler configures the mux to serve the "project" service
// "accept invite" endpoint.
func MountAcceptInviteHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/invites/{id}/accept", f)
}

// NewAcceptInviteHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "accept invite" endpoint.
func NewAcceptInviteHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeAcceptInviteRequest(mux, decoder)
		encodeResponse = EncodeAcceptInviteResponse(encoder)
		encodeError    = EncodeAcceptInviteError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "accept invite")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountRejectInviteHandler configures the mux to serve the "project" service
// "reject invite" endpoint.
func MountRejectInviteHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/invites/{id}/reject", f)
}

// NewRejectInviteHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "reject invite" endpoint.
func NewRejectInviteHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRejectInviteRequest(mux, decoder)
		encodeResponse = EncodeRejectInviteResponse(encoder)
		encodeError    = EncodeRejectInviteError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "reject invite")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountAddHandler configures the mux to serve the "project" service "add"
// endpoint.
func MountAddHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects", f)
}

// NewAddHandler creates a HTTP handler which loads the HTTP request and calls
// the "project" service "add" endpoint.
func NewAddHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeAddRequest(mux, decoder)
		encodeResponse = EncodeAddResponse(encoder)
		encodeError    = EncodeAddError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "add")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUpdateHandler configures the mux to serve the "project" service
// "update" endpoint.
func MountUpdateHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("PATCH", "/projects/{projectId}", f)
}

// NewUpdateHandler creates a HTTP handler which loads the HTTP request and
// calls the "project" service "update" endpoint.
func NewUpdateHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUpdateRequest(mux, decoder)
		encodeResponse = EncodeUpdateResponse(encoder)
		encodeError    = EncodeUpdateError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "update")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountGetHandler configures the mux to serve the "project" service "get"
// endpoint.
func MountGetHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/projects/{projectId}", f)
}

// NewGetHandler creates a HTTP handler which loads the HTTP request and calls
// the "project" service "get" endpoint.
func NewGetHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeGetRequest(mux, decoder)
		encodeResponse = EncodeGetResponse(encoder)
		encodeError    = EncodeGetError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "get")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListCommunityHandler configures the mux to serve the "project" service
// "list community" endpoint.
func MountListCommunityHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/projects", f)
}

// NewListCommunityHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "list community" endpoint.
func NewListCommunityHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListCommunityRequest(mux, decoder)
		encodeResponse = EncodeListCommunityResponse(encoder)
		encodeError    = EncodeListCommunityError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "list community")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountListMineHandler configures the mux to serve the "project" service "list
// mine" endpoint.
func MountListMineHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/user/projects", f)
}

// NewListMineHandler creates a HTTP handler which loads the HTTP request and
// calls the "project" service "list mine" endpoint.
func NewListMineHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeListMineRequest(mux, decoder)
		encodeResponse = EncodeListMineResponse(encoder)
		encodeError    = EncodeListMineError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "list mine")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountInviteHandler configures the mux to serve the "project" service
// "invite" endpoint.
func MountInviteHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/{projectId}/invite", f)
}

// NewInviteHandler creates a HTTP handler which loads the HTTP request and
// calls the "project" service "invite" endpoint.
func NewInviteHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeInviteRequest(mux, decoder)
		encodeResponse = EncodeInviteResponse(encoder)
		encodeError    = EncodeInviteError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "invite")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountRemoveUserHandler configures the mux to serve the "project" service
// "remove user" endpoint.
func MountRemoveUserHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/projects/{projectId}/members", f)
}

// NewRemoveUserHandler creates a HTTP handler which loads the HTTP request and
// calls the "project" service "remove user" endpoint.
func NewRemoveUserHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRemoveUserRequest(mux, decoder)
		encodeResponse = EncodeRemoveUserResponse(encoder)
		encodeError    = EncodeRemoveUserError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "remove user")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountAddStationHandler configures the mux to serve the "project" service
// "add station" endpoint.
func MountAddStationHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/{projectId}/stations/{stationId}", f)
}

// NewAddStationHandler creates a HTTP handler which loads the HTTP request and
// calls the "project" service "add station" endpoint.
func NewAddStationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeAddStationRequest(mux, decoder)
		encodeResponse = EncodeAddStationResponse(encoder)
		encodeError    = EncodeAddStationError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "add station")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountRemoveStationHandler configures the mux to serve the "project" service
// "remove station" endpoint.
func MountRemoveStationHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/projects/{projectId}/stations/{stationId}", f)
}

// NewRemoveStationHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "remove station" endpoint.
func NewRemoveStationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeRemoveStationRequest(mux, decoder)
		encodeResponse = EncodeRemoveStationResponse(encoder)
		encodeError    = EncodeRemoveStationError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "remove station")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDeleteHandler configures the mux to serve the "project" service
// "delete" endpoint.
func MountDeleteHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("DELETE", "/projects/{projectId}", f)
}

// NewDeleteHandler creates a HTTP handler which loads the HTTP request and
// calls the "project" service "delete" endpoint.
func NewDeleteHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDeleteRequest(mux, decoder)
		encodeResponse = EncodeDeleteResponse(encoder)
		encodeError    = EncodeDeleteError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "delete")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountUploadPhotoHandler configures the mux to serve the "project" service
// "upload photo" endpoint.
func MountUploadPhotoHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/projects/{projectId}/media", f)
}

// NewUploadPhotoHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "upload photo" endpoint.
func NewUploadPhotoHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeUploadPhotoRequest(mux, decoder)
		encodeResponse = EncodeUploadPhotoResponse(encoder)
		encodeError    = EncodeUploadPhotoError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "upload photo")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		data := &project.UploadPhotoRequestData{Payload: payload.(*project.UploadPhotoPayload), Body: r.Body}
		res, err := endpoint(ctx, data)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDownloadPhotoHandler configures the mux to serve the "project" service
// "download photo" endpoint.
func MountDownloadPhotoHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := handleProjectOrigin(h).(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/projects/{projectId}/media", f)
}

// NewDownloadPhotoHandler creates a HTTP handler which loads the HTTP request
// and calls the "project" service "download photo" endpoint.
func NewDownloadPhotoHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDownloadPhotoRequest(mux, decoder)
		encodeResponse = EncodeDownloadPhotoResponse(encoder)
		encodeError    = EncodeDownloadPhotoError(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "download photo")
		ctx = context.WithValue(ctx, goa.ServiceKey, "project")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCORSHandler configures the mux to serve the CORS endpoints for the
// service project.
func MountCORSHandler(mux goahttp.Muxer, h http.Handler) {
	h = handleProjectOrigin(h)
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("OPTIONS", "/projects/{projectId}/updates", f)
	mux.Handle("OPTIONS", "/projects/{projectId}/updates/{updateId}", f)
	mux.Handle("OPTIONS", "/projects/invites/pending", f)
	mux.Handle("OPTIONS", "/projects/invites/{token}", f)
	mux.Handle("OPTIONS", "/projects/{projectId}/invites/accept", f)
	mux.Handle("OPTIONS", "/projects/{projectId}/invites/reject", f)
	mux.Handle("OPTIONS", "/projects/invites/{id}/accept", f)
	mux.Handle("OPTIONS", "/projects/invites/{id}/reject", f)
	mux.Handle("OPTIONS", "/projects", f)
	mux.Handle("OPTIONS", "/projects/{projectId}", f)
	mux.Handle("OPTIONS", "/user/projects", f)
	mux.Handle("OPTIONS", "/projects/{projectId}/invite", f)
	mux.Handle("OPTIONS", "/projects/{projectId}/members", f)
	mux.Handle("OPTIONS", "/projects/{projectId}/stations/{stationId}", f)
	mux.Handle("OPTIONS", "/projects/{projectId}/media", f)
}

// NewCORSHandler creates a HTTP handler which returns a simple 200 response.
func NewCORSHandler() http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(200)
	})
}

// handleProjectOrigin applies the CORS response headers corresponding to the
// origin for the service project.
func handleProjectOrigin(h http.Handler) http.Handler {
	spec0 := regexp.MustCompile("(.+[.])?127.0.0.1:\\d+")
	spec1 := regexp.MustCompile("(.+[.])?192.168.\\d+.\\d+:\\d+")
	spec2 := regexp.MustCompile("(.+[.])?fieldkit.org:\\d+")
	spec3 := regexp.MustCompile("(.+[.])?local.fkdev.org:\\d+")
	spec4 := regexp.MustCompile("(.+[.])?localhost:\\d+")
	origHndlr := h.(http.HandlerFunc)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		origin := r.Header.Get("Origin")
		if origin == "" {
			// Not a CORS request
			origHndlr(w, r)
			return
		}
		if cors.MatchOriginRegexp(origin, spec0) {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOriginRegexp(origin, spec1) {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOriginRegexp(origin, spec2) {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOriginRegexp(origin, spec3) {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOriginRegexp(origin, spec4) {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOrigin(origin, "https://*.fieldkit.org") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOrigin(origin, "https://*.fieldkit.org:8080") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOrigin(origin, "https://*.fkdev.org") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOrigin(origin, "https://fieldkit.org") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOrigin(origin, "https://fieldkit.org:8080") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		if cors.MatchOrigin(origin, "https://fkdev.org") {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			w.Header().Set("Vary", "Origin")
			w.Header().Set("Access-Control-Expose-Headers", "Authorization, Content-Type")
			w.Header().Set("Access-Control-Allow-Credentials", "false")
			if acrm := r.Header.Get("Access-Control-Request-Method"); acrm != "" {
				// We are handling a preflight request
				w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS, POST, DELETE, PATCH, PUT")
				w.Header().Set("Access-Control-Allow-Headers", "Authorization, Content-Type")
			}
			origHndlr(w, r)
			return
		}
		origHndlr(w, r)
		return
	})
}

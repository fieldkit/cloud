// Code generated by goa v3.2.4, DO NOT EDIT.
//
// maps HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/fieldkit/cloud/server/api/design

package server

import (
	"context"
	"net/http"

	maps "github.com/fieldkit/cloud/server/api/gen/maps"
	mapsviews "github.com/fieldkit/cloud/server/api/gen/maps/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeCoverageResponse returns an encoder for responses returned by the maps
// coverage endpoint.
func EncodeCoverageResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*mapsviews.Map)
		enc := encoder(ctx, w)
		body := NewCoverageResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeCoverageError returns an encoder for errors returned by the coverage
// maps endpoint.
func EncodeCoverageError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "forbidden":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCoverageForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", "forbidden")
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "not-found":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCoverageNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", "not-found")
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "bad-request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCoverageBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad-request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "unauthorized":
			res := v.(maps.Unauthorized)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewCoverageUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", "unauthorized")
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalMapsviewsMapGeoJSONViewToMapGeoJSONResponseBody builds a value of
// type *MapGeoJSONResponseBody from a value of type *mapsviews.MapGeoJSONView.
func marshalMapsviewsMapGeoJSONViewToMapGeoJSONResponseBody(v *mapsviews.MapGeoJSONView) *MapGeoJSONResponseBody {
	res := &MapGeoJSONResponseBody{
		Type: *v.Type,
	}
	if v.Geometry != nil {
		res.Geometry = marshalMapsviewsMapGeometryViewToMapGeometryResponseBody(v.Geometry)
	}
	if v.Properties != nil {
		res.Properties = make(map[string]string, len(v.Properties))
		for key, val := range v.Properties {
			tk := key
			tv := val
			res.Properties[tk] = tv
		}
	}

	return res
}

// marshalMapsviewsMapGeometryViewToMapGeometryResponseBody builds a value of
// type *MapGeometryResponseBody from a value of type
// *mapsviews.MapGeometryView.
func marshalMapsviewsMapGeometryViewToMapGeometryResponseBody(v *mapsviews.MapGeometryView) *MapGeometryResponseBody {
	res := &MapGeometryResponseBody{
		Type: *v.Type,
	}
	if v.Coordinates != nil {
		res.Coordinates = make([]float64, len(v.Coordinates))
		for i, val := range v.Coordinates {
			res.Coordinates[i] = val
		}
	}

	return res
}

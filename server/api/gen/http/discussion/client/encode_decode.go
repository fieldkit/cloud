// Code generated by goa v3.2.4, DO NOT EDIT.
//
// discussion HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/fieldkit/cloud/server/api/design

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	discussion "github.com/fieldkit/cloud/server/api/gen/discussion"
	discussionviews "github.com/fieldkit/cloud/server/api/gen/discussion/views"
	goahttp "goa.design/goa/v3/http"
)

// BuildProjectRequest instantiates a HTTP request object with method and path
// set to call the "discussion" service "project" endpoint
func (c *Client) BuildProjectRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		projectID int32
	)
	{
		p, ok := v.(*discussion.ProjectPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("discussion", "project", "*discussion.ProjectPayload", v)
		}
		projectID = p.ProjectID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ProjectDiscussionPath(projectID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("discussion", "project", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeProjectRequest returns an encoder for requests sent to the discussion
// project server.
func EncodeProjectRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*discussion.ProjectPayload)
		if !ok {
			return goahttp.ErrInvalidType("discussion", "project", "*discussion.ProjectPayload", v)
		}
		if p.Auth != nil {
			head := *p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeProjectResponse returns a decoder for responses returned by the
// discussion project endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeProjectResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeProjectResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ProjectResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "project", err)
			}
			p := NewProjectDiscussionOK(&body)
			view := "default"
			vres := &discussionviews.Discussion{Projected: p, View: view}
			if err = discussionviews.ValidateDiscussion(vres); err != nil {
				return nil, goahttp.ErrValidationError("discussion", "project", err)
			}
			res := discussion.NewDiscussion(vres)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body ProjectUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "project", err)
			}
			err = ValidateProjectUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "project", err)
			}
			return nil, NewProjectUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body ProjectForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "project", err)
			}
			err = ValidateProjectForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "project", err)
			}
			return nil, NewProjectForbidden(&body)
		case http.StatusNotFound:
			var (
				body ProjectNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "project", err)
			}
			err = ValidateProjectNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "project", err)
			}
			return nil, NewProjectNotFound(&body)
		case http.StatusBadRequest:
			var (
				body ProjectBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "project", err)
			}
			err = ValidateProjectBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "project", err)
			}
			return nil, NewProjectBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("discussion", "project", resp.StatusCode, string(body))
		}
	}
}

// BuildDataRequest instantiates a HTTP request object with method and path set
// to call the "discussion" service "data" endpoint
func (c *Client) BuildDataRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DataDiscussionPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("discussion", "data", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDataRequest returns an encoder for requests sent to the discussion
// data server.
func EncodeDataRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*discussion.DataPayload)
		if !ok {
			return goahttp.ErrInvalidType("discussion", "data", "*discussion.DataPayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("bookmark", p.Bookmark)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDataResponse returns a decoder for responses returned by the
// discussion data endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeDataResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeDataResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body DataResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "data", err)
			}
			p := NewDataDiscussionOK(&body)
			view := "default"
			vres := &discussionviews.Discussion{Projected: p, View: view}
			if err = discussionviews.ValidateDiscussion(vres); err != nil {
				return nil, goahttp.ErrValidationError("discussion", "data", err)
			}
			res := discussion.NewDiscussion(vres)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body DataUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "data", err)
			}
			err = ValidateDataUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "data", err)
			}
			return nil, NewDataUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body DataForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "data", err)
			}
			err = ValidateDataForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "data", err)
			}
			return nil, NewDataForbidden(&body)
		case http.StatusNotFound:
			var (
				body DataNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "data", err)
			}
			err = ValidateDataNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "data", err)
			}
			return nil, NewDataNotFound(&body)
		case http.StatusBadRequest:
			var (
				body DataBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "data", err)
			}
			err = ValidateDataBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "data", err)
			}
			return nil, NewDataBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("discussion", "data", resp.StatusCode, string(body))
		}
	}
}

// BuildPostMessageRequest instantiates a HTTP request object with method and
// path set to call the "discussion" service "post message" endpoint
func (c *Client) BuildPostMessageRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PostMessageDiscussionPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("discussion", "post message", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePostMessageRequest returns an encoder for requests sent to the
// discussion post message server.
func EncodePostMessageRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*discussion.PostMessagePayload)
		if !ok {
			return goahttp.ErrInvalidType("discussion", "post message", "*discussion.PostMessagePayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewPostMessageRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("discussion", "post message", err)
		}
		return nil
	}
}

// DecodePostMessageResponse returns a decoder for responses returned by the
// discussion post message endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodePostMessageResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodePostMessageResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body PostMessageResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "post message", err)
			}
			err = ValidatePostMessageResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "post message", err)
			}
			res := NewPostMessageResultOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body PostMessageUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "post message", err)
			}
			err = ValidatePostMessageUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "post message", err)
			}
			return nil, NewPostMessageUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body PostMessageForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "post message", err)
			}
			err = ValidatePostMessageForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "post message", err)
			}
			return nil, NewPostMessageForbidden(&body)
		case http.StatusNotFound:
			var (
				body PostMessageNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "post message", err)
			}
			err = ValidatePostMessageNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "post message", err)
			}
			return nil, NewPostMessageNotFound(&body)
		case http.StatusBadRequest:
			var (
				body PostMessageBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "post message", err)
			}
			err = ValidatePostMessageBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "post message", err)
			}
			return nil, NewPostMessageBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("discussion", "post message", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMessageRequest instantiates a HTTP request object with method and
// path set to call the "discussion" service "update message" endpoint
func (c *Client) BuildUpdateMessageRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		postID int64
	)
	{
		p, ok := v.(*discussion.UpdateMessagePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("discussion", "update message", "*discussion.UpdateMessagePayload", v)
		}
		postID = p.PostID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMessageDiscussionPath(postID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("discussion", "update message", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMessageRequest returns an encoder for requests sent to the
// discussion update message server.
func EncodeUpdateMessageRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*discussion.UpdateMessagePayload)
		if !ok {
			return goahttp.ErrInvalidType("discussion", "update message", "*discussion.UpdateMessagePayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewUpdateMessageRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("discussion", "update message", err)
		}
		return nil
	}
}

// DecodeUpdateMessageResponse returns a decoder for responses returned by the
// discussion update message endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeUpdateMessageResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeUpdateMessageResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMessageResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "update message", err)
			}
			err = ValidateUpdateMessageResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "update message", err)
			}
			res := NewUpdateMessageResultOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body UpdateMessageUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "update message", err)
			}
			err = ValidateUpdateMessageUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "update message", err)
			}
			return nil, NewUpdateMessageUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body UpdateMessageForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "update message", err)
			}
			err = ValidateUpdateMessageForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "update message", err)
			}
			return nil, NewUpdateMessageForbidden(&body)
		case http.StatusNotFound:
			var (
				body UpdateMessageNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "update message", err)
			}
			err = ValidateUpdateMessageNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "update message", err)
			}
			return nil, NewUpdateMessageNotFound(&body)
		case http.StatusBadRequest:
			var (
				body UpdateMessageBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "update message", err)
			}
			err = ValidateUpdateMessageBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "update message", err)
			}
			return nil, NewUpdateMessageBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("discussion", "update message", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMessageRequest instantiates a HTTP request object with method and
// path set to call the "discussion" service "delete message" endpoint
func (c *Client) BuildDeleteMessageRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		postID int64
	)
	{
		p, ok := v.(*discussion.DeleteMessagePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("discussion", "delete message", "*discussion.DeleteMessagePayload", v)
		}
		postID = p.PostID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMessageDiscussionPath(postID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("discussion", "delete message", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMessageRequest returns an encoder for requests sent to the
// discussion delete message server.
func EncodeDeleteMessageRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*discussion.DeleteMessagePayload)
		if !ok {
			return goahttp.ErrInvalidType("discussion", "delete message", "*discussion.DeleteMessagePayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeDeleteMessageResponse returns a decoder for responses returned by the
// discussion delete message endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDeleteMessageResponse may return the following errors:
//	- "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//	- "forbidden" (type *goa.ServiceError): http.StatusForbidden
//	- "not-found" (type *goa.ServiceError): http.StatusNotFound
//	- "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeDeleteMessageResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusUnauthorized:
			var (
				body DeleteMessageUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "delete message", err)
			}
			err = ValidateDeleteMessageUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "delete message", err)
			}
			return nil, NewDeleteMessageUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body DeleteMessageForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "delete message", err)
			}
			err = ValidateDeleteMessageForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "delete message", err)
			}
			return nil, NewDeleteMessageForbidden(&body)
		case http.StatusNotFound:
			var (
				body DeleteMessageNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "delete message", err)
			}
			err = ValidateDeleteMessageNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "delete message", err)
			}
			return nil, NewDeleteMessageNotFound(&body)
		case http.StatusBadRequest:
			var (
				body DeleteMessageBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("discussion", "delete message", err)
			}
			err = ValidateDeleteMessageBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("discussion", "delete message", err)
			}
			return nil, NewDeleteMessageBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("discussion", "delete message", resp.StatusCode, string(body))
		}
	}
}

// unmarshalThreadedPostResponseBodyToDiscussionviewsThreadedPostView builds a
// value of type *discussionviews.ThreadedPostView from a value of type
// *ThreadedPostResponseBody.
func unmarshalThreadedPostResponseBodyToDiscussionviewsThreadedPostView(v *ThreadedPostResponseBody) *discussionviews.ThreadedPostView {
	res := &discussionviews.ThreadedPostView{
		ID:        v.ID,
		CreatedAt: v.CreatedAt,
		UpdatedAt: v.UpdatedAt,
		Body:      v.Body,
		Bookmark:  v.Bookmark,
	}
	res.Author = unmarshalPostAuthorResponseBodyToDiscussionviewsPostAuthorView(v.Author)
	res.Replies = make([]*discussionviews.ThreadedPostView, len(v.Replies))
	for i, val := range v.Replies {
		res.Replies[i] = unmarshalThreadedPostResponseBodyToDiscussionviewsThreadedPostView(val)
	}

	return res
}

// unmarshalPostAuthorResponseBodyToDiscussionviewsPostAuthorView builds a
// value of type *discussionviews.PostAuthorView from a value of type
// *PostAuthorResponseBody.
func unmarshalPostAuthorResponseBodyToDiscussionviewsPostAuthorView(v *PostAuthorResponseBody) *discussionviews.PostAuthorView {
	res := &discussionviews.PostAuthorView{
		ID:   v.ID,
		Name: v.Name,
	}
	if v.Photo != nil {
		res.Photo = unmarshalAuthorPhotoResponseBodyToDiscussionviewsAuthorPhotoView(v.Photo)
	}

	return res
}

// unmarshalAuthorPhotoResponseBodyToDiscussionviewsAuthorPhotoView builds a
// value of type *discussionviews.AuthorPhotoView from a value of type
// *AuthorPhotoResponseBody.
func unmarshalAuthorPhotoResponseBodyToDiscussionviewsAuthorPhotoView(v *AuthorPhotoResponseBody) *discussionviews.AuthorPhotoView {
	if v == nil {
		return nil
	}
	res := &discussionviews.AuthorPhotoView{
		URL: v.URL,
	}

	return res
}

// marshalDiscussionNewPostToNewPostRequestBody builds a value of type
// *NewPostRequestBody from a value of type *discussion.NewPost.
func marshalDiscussionNewPostToNewPostRequestBody(v *discussion.NewPost) *NewPostRequestBody {
	res := &NewPostRequestBody{
		ThreadID:  v.ThreadID,
		Body:      v.Body,
		ProjectID: v.ProjectID,
		Bookmark:  v.Bookmark,
	}

	return res
}

// marshalNewPostRequestBodyToDiscussionNewPost builds a value of type
// *discussion.NewPost from a value of type *NewPostRequestBody.
func marshalNewPostRequestBodyToDiscussionNewPost(v *NewPostRequestBody) *discussion.NewPost {
	res := &discussion.NewPost{
		ThreadID:  v.ThreadID,
		Body:      v.Body,
		ProjectID: v.ProjectID,
		Bookmark:  v.Bookmark,
	}

	return res
}

// unmarshalThreadedPostResponseBodyToDiscussionThreadedPost builds a value of
// type *discussion.ThreadedPost from a value of type *ThreadedPostResponseBody.
func unmarshalThreadedPostResponseBodyToDiscussionThreadedPost(v *ThreadedPostResponseBody) *discussion.ThreadedPost {
	res := &discussion.ThreadedPost{
		ID:        *v.ID,
		CreatedAt: *v.CreatedAt,
		UpdatedAt: *v.UpdatedAt,
		Body:      *v.Body,
		Bookmark:  v.Bookmark,
	}
	res.Author = unmarshalPostAuthorResponseBodyToDiscussionPostAuthor(v.Author)
	res.Replies = make([]*discussion.ThreadedPost, len(v.Replies))
	for i, val := range v.Replies {
		res.Replies[i] = unmarshalThreadedPostResponseBodyToDiscussionThreadedPost(val)
	}

	return res
}

// unmarshalPostAuthorResponseBodyToDiscussionPostAuthor builds a value of type
// *discussion.PostAuthor from a value of type *PostAuthorResponseBody.
func unmarshalPostAuthorResponseBodyToDiscussionPostAuthor(v *PostAuthorResponseBody) *discussion.PostAuthor {
	res := &discussion.PostAuthor{
		ID:   *v.ID,
		Name: *v.Name,
	}
	if v.Photo != nil {
		res.Photo = unmarshalAuthorPhotoResponseBodyToDiscussionAuthorPhoto(v.Photo)
	}

	return res
}

// unmarshalAuthorPhotoResponseBodyToDiscussionAuthorPhoto builds a value of
// type *discussion.AuthorPhoto from a value of type *AuthorPhotoResponseBody.
func unmarshalAuthorPhotoResponseBodyToDiscussionAuthorPhoto(v *AuthorPhotoResponseBody) *discussion.AuthorPhoto {
	if v == nil {
		return nil
	}
	res := &discussion.AuthorPhoto{
		URL: *v.URL,
	}

	return res
}

// Code generated by goa v3.2.4, DO NOT EDIT.
//
// maps service
//
// Command:
// $ goa gen github.com/fieldkit/cloud/server/api/design

package maps

import (
	"context"

	mapsviews "github.com/fieldkit/cloud/server/api/gen/maps/views"
	goa "goa.design/goa/v3/pkg"
)

// Service is the maps service interface.
type Service interface {
	// Coverage implements coverage.
	Coverage(context.Context) (res *Map, err error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "maps"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [1]string{"coverage"}

// Map is the result type of the maps service coverage method.
type Map struct {
	Features []*MapGeoJSON
}

type MapGeoJSON struct {
	Type       string
	Geometry   *MapGeometry
	Properties map[string]string
}

type MapGeometry struct {
	Type        string
	Coordinates []float64
}

// credentials are invalid
type Unauthorized string

// Error returns an error description.
func (e Unauthorized) Error() string {
	return "credentials are invalid"
}

// ErrorName returns "unauthorized".
func (e Unauthorized) ErrorName() string {
	return "unauthorized"
}

// MakeUnauthorized builds a goa.ServiceError from an error.
func MakeUnauthorized(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unauthorized",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeForbidden builds a goa.ServiceError from an error.
func MakeForbidden(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "forbidden",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "not-found",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadRequest builds a goa.ServiceError from an error.
func MakeBadRequest(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad-request",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewMap initializes result type Map from viewed result type Map.
func NewMap(vres *mapsviews.Map) *Map {
	return newMap(vres.Projected)
}

// NewViewedMap initializes viewed result type Map from result type Map using
// the given view.
func NewViewedMap(res *Map, view string) *mapsviews.Map {
	p := newMapView(res)
	return &mapsviews.Map{Projected: p, View: "default"}
}

// newMap converts projected type Map to service type Map.
func newMap(vres *mapsviews.MapView) *Map {
	res := &Map{}
	if vres.Features != nil {
		res.Features = make([]*MapGeoJSON, len(vres.Features))
		for i, val := range vres.Features {
			res.Features[i] = transformMapsviewsMapGeoJSONViewToMapGeoJSON(val)
		}
	}
	return res
}

// newMapView projects result type Map to projected type MapView using the
// "default" view.
func newMapView(res *Map) *mapsviews.MapView {
	vres := &mapsviews.MapView{}
	if res.Features != nil {
		vres.Features = make([]*mapsviews.MapGeoJSONView, len(res.Features))
		for i, val := range res.Features {
			vres.Features[i] = transformMapGeoJSONToMapsviewsMapGeoJSONView(val)
		}
	}
	return vres
}

// newMapGeoJSON converts projected type MapGeoJSON to service type MapGeoJSON.
func newMapGeoJSON(vres *mapsviews.MapGeoJSONView) *MapGeoJSON {
	res := &MapGeoJSON{}
	if vres.Type != nil {
		res.Type = *vres.Type
	}
	if vres.Properties != nil {
		res.Properties = make(map[string]string, len(vres.Properties))
		for key, val := range vres.Properties {
			tk := key
			tv := val
			res.Properties[tk] = tv
		}
	}
	if vres.Geometry != nil {
		res.Geometry = newMapGeometry(vres.Geometry)
	}
	return res
}

// newMapGeoJSONView projects result type MapGeoJSON to projected type
// MapGeoJSONView using the "default" view.
func newMapGeoJSONView(res *MapGeoJSON) *mapsviews.MapGeoJSONView {
	vres := &mapsviews.MapGeoJSONView{
		Type: &res.Type,
	}
	if res.Properties != nil {
		vres.Properties = make(map[string]string, len(res.Properties))
		for key, val := range res.Properties {
			tk := key
			tv := val
			vres.Properties[tk] = tv
		}
	}
	if res.Geometry != nil {
		vres.Geometry = newMapGeometryView(res.Geometry)
	}
	return vres
}

// newMapGeometry converts projected type MapGeometry to service type
// MapGeometry.
func newMapGeometry(vres *mapsviews.MapGeometryView) *MapGeometry {
	res := &MapGeometry{}
	if vres.Type != nil {
		res.Type = *vres.Type
	}
	if vres.Coordinates != nil {
		res.Coordinates = make([]float64, len(vres.Coordinates))
		for i, val := range vres.Coordinates {
			res.Coordinates[i] = val
		}
	}
	return res
}

// newMapGeometryView projects result type MapGeometry to projected type
// MapGeometryView using the "default" view.
func newMapGeometryView(res *MapGeometry) *mapsviews.MapGeometryView {
	vres := &mapsviews.MapGeometryView{
		Type: &res.Type,
	}
	if res.Coordinates != nil {
		vres.Coordinates = make([]float64, len(res.Coordinates))
		for i, val := range res.Coordinates {
			vres.Coordinates[i] = val
		}
	}
	return vres
}

// transformMapsviewsMapGeoJSONViewToMapGeoJSON builds a value of type
// *MapGeoJSON from a value of type *mapsviews.MapGeoJSONView.
func transformMapsviewsMapGeoJSONViewToMapGeoJSON(v *mapsviews.MapGeoJSONView) *MapGeoJSON {
	if v == nil {
		return nil
	}
	res := &MapGeoJSON{
		Type: *v.Type,
	}
	if v.Geometry != nil {
		res.Geometry = transformMapsviewsMapGeometryViewToMapGeometry(v.Geometry)
	}
	if v.Properties != nil {
		res.Properties = make(map[string]string, len(v.Properties))
		for key, val := range v.Properties {
			tk := key
			tv := val
			res.Properties[tk] = tv
		}
	}

	return res
}

// transformMapsviewsMapGeometryViewToMapGeometry builds a value of type
// *MapGeometry from a value of type *mapsviews.MapGeometryView.
func transformMapsviewsMapGeometryViewToMapGeometry(v *mapsviews.MapGeometryView) *MapGeometry {
	res := &MapGeometry{
		Type: *v.Type,
	}
	if v.Coordinates != nil {
		res.Coordinates = make([]float64, len(v.Coordinates))
		for i, val := range v.Coordinates {
			res.Coordinates[i] = val
		}
	}

	return res
}

// transformMapGeoJSONToMapsviewsMapGeoJSONView builds a value of type
// *mapsviews.MapGeoJSONView from a value of type *MapGeoJSON.
func transformMapGeoJSONToMapsviewsMapGeoJSONView(v *MapGeoJSON) *mapsviews.MapGeoJSONView {
	res := &mapsviews.MapGeoJSONView{
		Type: &v.Type,
	}
	if v.Geometry != nil {
		res.Geometry = transformMapGeometryToMapsviewsMapGeometryView(v.Geometry)
	}
	if v.Properties != nil {
		res.Properties = make(map[string]string, len(v.Properties))
		for key, val := range v.Properties {
			tk := key
			tv := val
			res.Properties[tk] = tv
		}
	}

	return res
}

// transformMapGeometryToMapsviewsMapGeometryView builds a value of type
// *mapsviews.MapGeometryView from a value of type *MapGeometry.
func transformMapGeometryToMapsviewsMapGeometryView(v *MapGeometry) *mapsviews.MapGeometryView {
	res := &mapsviews.MapGeometryView{
		Type: &v.Type,
	}
	if v.Coordinates != nil {
		res.Coordinates = make([]float64, len(v.Coordinates))
		for i, val := range v.Coordinates {
			res.Coordinates[i] = val
		}
	}

	return res
}
